diff --git a/fs/aio.c b/fs/aio.c
index 5f577a6..236c94a 100644
--- a/fs/aio.c
+++ b/fs/aio.c
@@ -30,6 +30,7 @@ #include <linux/aio.h>
 #include <linux/highmem.h>
 #include <linux/workqueue.h>
 #include <linux/security.h>
+#include <linux/eventpoll.h>
 
 #include <asm/kmap_types.h>
 #include <asm/uaccess.h>
@@ -1487,6 +1488,9 @@ static ssize_t aio_setup_iocb(struct kio
 		if (file->f_op->aio_fsync)
 			kiocb->ki_retry = aio_fsync;
 		break;
+	case IOCB_CMD_EPOLL_WAIT:
+		kiocb->ki_retry = eventpoll_aio_wait;
+		break;
 	default:
 		dprintk("EINVAL: io_submit: no operation provided\n");
 		ret = -EINVAL;
diff --git a/fs/eventpoll.c b/fs/eventpoll.c
index 3ae644e..6b78ada 100644
--- a/fs/eventpoll.c
+++ b/fs/eventpoll.c
@@ -35,6 +35,7 @@ #include <linux/eventpoll.h>
 #include <linux/mount.h>
 #include <linux/bitops.h>
 #include <linux/mutex.h>
+#include <linux/aio.h>
 #include <asm/uaccess.h>
 #include <asm/system.h>
 #include <asm/io.h>
@@ -642,6 +643,150 @@ eexit_1:
 	return error;
 }
 
+static void eventpoll_aio_timer(unsigned long data)
+{
+	struct kiocb *iocb = (struct kiocb *)data;
+	struct timer_list *timer = (struct timer_list *)iocb->private;
+	struct file *file = iocb->ki_filp;
+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
+	unsigned long flags;
+
+	(void)del_timer(timer);
+	write_lock_irqsave(&ep->lock, flags);
+	__wake_up_locked(&ep->wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);
+	write_unlock_irqrestore(&ep->lock, flags);
+}
+
+static int aio_epoll_cancel(struct kiocb *iocb, struct io_event *event)
+{
+	struct file *file = iocb->ki_filp;
+	struct eventpoll *ep = (struct eventpoll *)file->private_data;
+	int ret = -1;
+	struct list_head *list;
+	int seen = 0;
+
+	write_lock_irq(&ep->lock);
+
+	if (iocb->private)
+		del_timer((struct timer_list *)iocb->private);
+	/*
+	 *  We need to know whether the event was removed from the wait
+	 *  queue in order to return the proper status to the cancellation
+	 *  code.
+	 */
+	list = &ep->wq.task_list;
+
+	do {
+		struct list_head *next;
+		if (list == &iocb->ki_wait.task_list)
+			seen++;
+		next = list->next;
+		if (next->prev != list) {
+			seen += 2;
+			break;
+		}
+		list = next;
+	} while (list != &ep->wq.task_list);
+
+	if (seen == 1) {
+		__remove_wait_queue(&ep->wq, &iocb->ki_wait);
+		ret = 0;
+	}
+	write_unlock_irq(&ep->lock);
+
+	if (ret == 0) {
+		/* successfully cancelled request */
+		kfree(iocb->private);
+		iocb->private = NULL;
+		/* drop the i/o reference */
+		aio_put_req(iocb);
+	} else
+		ret = -EAGAIN;
+
+	event->res = event->res2 = 0;
+	/* drop the cancel reference */
+	aio_put_req(iocb);
+
+	return ret;
+}
+
+/*
+ * iocb->ki_nbytes -- number of events
+ * iocb->ki_pos    -- relative timeout in milliseconds
+ * iocb->private   -- NULL first go;  after that, it's set to the the
+ *                    absolute timeout in jiffies.
+ */
+ssize_t eventpoll_aio_wait(struct kiocb *iocb)
+{
+	struct file *file = iocb->ki_filp;
+	ssize_t ret = -EINVAL;
+	int relative_ms;
+	unsigned long expires;
+	unsigned long now;
+	struct timer_list *timer;
+
+	if (!is_file_epoll(file) || iocb->ki_nbytes > EP_MAX_EVENTS ||
+	    iocb->ki_nbytes <= 0)
+		return -EINVAL;
+
+	if (!iocb->private) {
+		/*
+		 *  Note that we unconditionally allocate a timer, but we
+		 *  only use it if a timeout was specified.  Otherwise, it
+		 *  is just a holder for the "infinite" value.
+		 */
+		timer = kmalloc(sizeof(struct timer_list), GFP_KERNEL);
+		if (!timer)
+			return -ENOMEM;
+
+		if ((long)iocb->ki_pos < 0 || iocb->ki_pos >= EP_MAX_MSTIMEO)
+			expires = MAX_SCHEDULE_TIMEOUT;
+		else
+			expires = jiffies + msecs_to_jiffies(iocb->ki_pos);
+
+		init_timer(timer);
+		timer->function = eventpoll_aio_timer;
+		timer->data = (unsigned long)iocb;
+		timer->expires = expires;
+	} else {
+		timer = (struct timer_list *)iocb->private;
+		expires = timer->expires;
+	}
+
+	now = jiffies;
+	if (timer->expires == MAX_SCHEDULE_TIMEOUT)
+		relative_ms = EP_MAX_MSTIMEO;
+	else if (time_before(now, expires))
+		relative_ms = jiffies_to_msecs(expires - now);
+	else
+		relative_ms = 0;
+
+	iocb->ki_cancel = aio_epoll_cancel;
+	ret = ep_poll(file->private_data,
+		      (struct epoll_event __user *)iocb->ki_buf,
+		      iocb->ki_nbytes, relative_ms);
+
+	/*
+	 *  If a timeout was specified, ep_poll returned retry, and we have
+	 *  not yet registered a timer, go ahead and register one.
+	 */
+	if (ret == -EIOCBRETRY && !iocb->private) {
+		iocb->private = timer;
+		add_timer(timer);
+	}
+
+	/*
+	 *  Did we get any events?
+	 */
+	if (ret >= 0) {
+		iocb->ki_cancel = NULL;
+		(void)del_timer(timer);
+		kfree(timer);
+		iocb->private = NULL;
+	}
+
+	return ret;
+}
 
 /*
  * Implement the event wait interface for the eventpoll file. It is the kernel
@@ -1564,6 +1709,12 @@ retry:
 
 	res = 0;
 	if (list_empty(&ep->rdllist)) {
+		if (in_aio() && jtimeout) {
+			__add_wait_queue(&ep->wq, current->io_wait);
+			res = -EIOCBRETRY;
+			write_unlock_irqrestore(&ep->lock, flags);
+			goto out;
+		}
 		/*
 		 * We don't have any available event to return to the caller.
 		 * We need to sleep here, and we will be wake up by
@@ -1608,7 +1759,7 @@ retry:
 	if (!res && eavail &&
 	    !(res = ep_events_transfer(ep, events, maxevents)) && jtimeout)
 		goto retry;
-
+out:
 	return res;
 }
 
diff --git a/include/linux/aio_abi.h b/include/linux/aio_abi.h
index e3ca0a4..292c811 100644
--- a/include/linux/aio_abi.h
+++ b/include/linux/aio_abi.h
@@ -43,6 +43,7 @@ enum {
 	IOCB_CMD_NOOP = 6,
 	IOCB_CMD_PREADV = 7,
 	IOCB_CMD_PWRITEV = 8,
+  	IOCB_CMD_EPOLL_WAIT = 9,
 };
 
 /* read() from /dev/aio returns these structures. */
diff --git a/include/linux/eventpoll.h b/include/linux/eventpoll.h
index 84cfa8b..ed04500 100644
--- a/include/linux/eventpoll.h
+++ b/include/linux/eventpoll.h
@@ -62,6 +62,9 @@ static inline void eventpoll_init_file(s
 /* Used to release the epoll bits inside the "struct file" */
 void eventpoll_release_file(struct file *file);
 
+/* Used to provide epoll_wait() to sys_io_submit() */
+ssize_t eventpoll_aio_wait(struct kiocb *iocb);
+
 /*
  * This is called from inside fs/file_table.c:__fput() to unlink files
  * from the eventpoll interface. We need to have this facility to cleanup
